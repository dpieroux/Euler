--------------------------------------------------------------------------------
-- |
-- Module      : Pythagoras
-- Description : Pythagorean triples
-- Copyright   : (c) Didier Pieroux, 2017
-- License     : MIT
-- Maintainer  : Didier Pieroux
-- Portability : portable
--
-- This module generates the Pythagorean triples. See [1].
--
-- [1] <https://en.wikipedia.org/wiki/Pythagorean_triple>
--------------------------------------------------------------------------------

module Pythagoras (genPrimTriples) where

import Data.List.Ordered

-- | Generates a comprehensive list of primitive Pythagorean triples.
--
-- The triples (a, b, c) returned satisfy a² + b² = c² and a<b. They are sorted
-- by increasing c, and then by increasing a.

genPrimTriples :: Integral int => () -> [(int, int, int)]
genPrimTriples _ = genPrims' [mkPrimItem 2 1]

--------------------------------------------------------------------------------
-- Primitive triples generation: implementation details
--------------------------------------------------------------------------------
--
-- All the primitive Pythagorean triples (a, b c) can be obtained from the set
-- of pairs (m, n) with 0 < n < m, m and n coprime and of opposite parity. Given
-- such a pair, it comes (a, b, c) = (min, max, m²+n²) with min (resp. max) the
-- minimum (resp. maximum) between m²-n² and 2mn. This relation establishes thus
-- a bijection between the set of valid pairs and the set of primitive
-- Pythagorean triples (a, b c) with a < b < c.
--
-- In what follows, let's called the value c obtained from a pair the hypotenuse
-- of the pair, and the value a its small side.
--
-- Generating the sequence with all primitive triples is thus equivalent to
-- generating the sequence of all the valid pairs (m, n). This can be achieved
-- very easily, for instance be considering all m>1 and then all n valid for
-- each given m. However, the triples so obtained are not in a natural order. So
-- we add the additional constraint that the triples must be generated by
-- increasing hypotenuses, and increasing small sides in case of equal
-- hypotenuses.
--
-- To do so, let's arrange the valid pairs (m, n) in a table, with increasing m
-- rightwards and increasing n downwards:
--
--      (2,1)    (3,2)    (4,1)    (5,2)    (6,1)    (7,2)    (8,1)    ...
--                        (4,3)    (5,4)    (6,5)    (7,4)    (8,3)     .
--                                                   (7,5)    (8,5)     .
--                                                                      .
--
-- It is trivial to show that
--      * any element has a smaller hypotenuse than the one below it (if such an
--        element exists): c(m, n) < c(m, n+2), assuming n+2<m;
--      * any element of the first row has a smaller hypotenuse than the one to
--        its right: c(m, 1) < c(m+1, 2) for m even,
--                   c(m, 2) < c(m+1, 1) for m odd.
--
-- We consider now that each pair of the table is a generator of up to 2 other
-- pairs as follows:
--      - any pair generates the pair just below it, if it exists.
--      - any pair of the first row generate the pair to its right.
--
-- This is illustrated in the diagram below:
--
--      (2,1) -> (3,2) -> (4,1) -> (5,2) -> (6,1) -> (7,2) -> (8,1) -> ...
--                          V        V        V        V        V
--                        (4,3)    (5,4)    (6,5)    (7,4)    (8,3)     .
--                                                     V        V       .
--                                                   (7,5)    (8,5)     .
--
-- It is trivial to show that the hypotenuse of a generated element is always
-- greater than the one of its generator.
--
-- Let us now consider the following algorithm:
--      1. Initialise a list L as the singleton with the first pair (2,1).
--      2. Then iterate forever:
--          2.1. Get and remove the head h of L.
--          2.2. Yield the corresponding triple to the user.
--          2.3. Insert in L the elements generated from h so that the pairs of
--               L are kept sorted by increasing hypotenuses first and small
--               sides second.
--
-- Theorem: The elements so yielded are sorted by increasing hypotenuses first
--          and small sides second.
--
--     For the demonstration, let h be the head of L at a given time. Because L
--     is kept sorted, by construction all elements of L other then h have at
--     least an hypotenuse as large as h, and in case of equal hypotenuse, a
--     small side larger than h.
--
--     Could it be possible that a pair is added later on to L with either a
--     smaller hypotenuse than h, or with an equal hypotenuse but a smaller
--     small side?
--
--     The answer is no. To insert such an item, the hypotenuse of the generator
--     pair should be smaller than h's one. However, there is no such element in
--     L at the time h is the head, since h has the smallest hypotenuse of the
--     element of h. So, all elements that will be inserted later one will have
--     a hypotenuse larger than h's one.
--
--     Otherwise said, the first time a pair with a given hypotenuse becomes the
--     head of L, all the pairs with a smaller hypotenuse have already been
--     returned to the user, and all the pairs with a equal hypotenuse are
--     already in L. As the latter are order by small side first, the elements
--     will be yielded in the required order.                               CQFD
--
--------------------------------------------------------------------------------

-- A primitive pair, with its precomputed lengths.
--
-- Such an item is used as element of the table described above.
data PrimItem a = PrimItem (a, a) (a, a, a) deriving Eq

instance Ord a => Ord (PrimItem a) where
    compare (PrimItem _ (sml, _, hyp)) (PrimItem _ (sml', _, hyp'))
        = case compare hyp hyp' of
            LT -> LT
            EQ -> compare sml sml'
            GT -> GT


-- Build a PrimItem from m and n
--
-- Note: when building a PrimItem, all elements are evaluated, excepted the
-- hypotenuse. However, the latter has to be evaluated when the item is inserted
-- in the ordered list. So we don't stay with trailing unevaluated expressions.
--
mkPrimItem :: Integral int => int -> int -> PrimItem int
mkPrimItem m n = PrimItem (m, n) (if a < b then (a, b, hyp) else (b, a, hyp))
  where {m²=m*m; n²=n*n; a = m²-n²; b = 2*m*n; hyp=m²+n²}


-- Generate the primitive triples in the required order.
--
-- Implementation of the algorithm explained above
--
genPrims' :: Integral int => [PrimItem int] -> [(int, int, int)]
genPrims' ((PrimItem (m, n) triple):pairs) = triple : (genPrims' pairs')
  where
    pairs' = if n>2 then downExt else downRightExt

    downExt = if n'<m then insertSet (mkPrimItem m n') pairs else pairs
      where n' = until ((1==) . gcd m) (+2) (n+2)

    downRightExt = insertSet (mkPrimItem (m+1) (3-n)) downExt









