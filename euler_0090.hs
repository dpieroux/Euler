{-
--------------------------------------------------------------------------------
In fact, by carefully choosing the digits on both cubes it is possible to
display all of the square numbers below one-hundred: 01, 04, 09, 16, 25, 36,
49, 64, and 81.

For example, one way this can be achieved is by placing {0, 5, 6, 7, 8, 9} on
one cube and {1, 2, 3, 4, 8, 9} on the other cube.

However, for this problem we shall allow the 6 or 9 to be turned upside-down so
that an arrangement like {0, 5, 6, 7, 8, 9} and {1, 2, 3, 4, 6, 7} allows for
all nine square numbers to be displayed; otherwise it would be impossible to
obtain 09.

In determining a distinct arrangement we are interested in the digits on each
cube, not the order.

{1, 2, 3, 4, 5, 6} is equivalent to {3, 6, 4, 1, 2, 5}
{1, 2, 3, 4, 5, 6} is distinct from {1, 2, 3, 4, 5, 9}

But because we are allowing 6 and 9 to be reversed, the two distinct sets in
the last example both represent the extended set {1, 2, 3, 4, 5, 6, 9} for the
purpose of forming 2-digit numbers.

How many distinct arrangements of the two cubes allow for all of the square
numbers to be displayed?
--------------------------------------------------------------------------------
-}

import Data.List(group)

-- Let A and B be the two cubes. The answer to the problem is the sum, over all
-- configurations of A, of the number of configurations of B compatible with the
-- display of all square numbers.

-- The approach implemented here is to generate all configurations for the pair
-- (A, B) and to check if it is possible to generate all the square numbers from
-- each of them.

-- Because there are C(10, 6)^2 configuration for all the pairs of A and B, but
-- that about half of them are redundant (see below) we are left with about
-- 210*210/2 = 22,100 different configurations, which seems quite manageable.

-- Let start by implementing a function to return all combinations of k elements
-- from a list. -}

combination :: Int -> [a] -> [[a]]
combination k ls | k < 1     = []
                 | k > len   = []
                 | otherwise = combi k ls len
  where
    len = length ls

    combi :: Int -> [a] -> Int -> [[a]]
    combi 1 ls _ = [[x] | x <- ls]
    combi k (l:ls) len = combi1 ++ combi2
      where
        combi1 = map (l:) $ combi (k-1) ls (len-1)
        combi2 = if (k<len) then (combi k ls (len-1)) else []

-- 0 being a digit necessary to build 1, 4 and 9, we choose to impose it to A.
-- Therefore the possible combinations of A are given by: q

digits = [0..9] :: [Int]
ass = map (0:) $ combination 5 $ tail digits

-- Exchanging A and B doesn't count as another configuration. Also, to avoid
-- generating equivalent configuration, we retrain B "to be equal or larger"
-- then A. Here we define the value of a cube as the number obtained by writing
-- all its digit in increasing order; for instance e.g. the value of the cube
-- {0, 3, 4, 5, 7, 8} is 34578. The set of pairs (A, B) is thus given by the
-- following expression, in which all 9 digits are replaced by '6':

cubePairs = [(as', bs') | as <- ass,
                         bs <- combination 6 digits,
                         as <= bs,
                         let as' = [(if a == 9 then 6 else a) | a <- as],
                         let bs' = [(if b == 9 then 6 else b) | b <- bs]]

--The length of cubePairs is 18585. This is less then the 22,100 mentionned
--above because of the additional restriction that the A's must have 0.

-- Accounting for the fact that 9 can be replaced by 6, 9 is equivalent to 6 and
-- 49 is equivalent to 46. In addition, 64 is equivalent to 46. The list of
-- pairs of digits to be generated by the cubes is thus:

digitPairs = [(0, 1), (0, 4), (0, 6), (1, 6),
              (2, 5), (3, 6), (4, 6), (8, 1)] :: [(Int, Int)]


-- Testing if a pair of cubes can represent a pair of digits is trivial:

validCubesForDigits as bs (x, y) =  (elem x as) && (elem y bs)
                                 || (elem x bs) && (elem y as)

-- With this, testing the validity of a pair of cubes is easy:

validCubes (as, bs) = all (validCubesForDigits as bs) digitPairs

-- we now have to filter out all the invalid cubes and return the length of the
-- list of the valid ones:

main = putStrLn $ show $ length $ filter validCubes cubePairs

-- The answer is: 1217